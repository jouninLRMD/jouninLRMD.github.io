---
layout: post
title: "Clase 08"
main-class: 'clase'
permalink: /MuestreoySeriesdeTiempo/MyST:title.html
tags:

introduction: |
  Operador de rezagos <br/>
  Representación de un proceso lineal AR, MA y ARMA. <br/>
  Condiciones de Estacionariedad e invertibilidad. 
header-includes:
   - \usepackage{amsmath,amssymb,amsthm,amsfonts}
   - \usepackage[sectionbib]{natbib}
   - \usepackage[hidelinks]{hyperref}
output:
  md_document:
    variant: markdown_strict+backtick_code_blocks+autolink_bare_uris+ascii_identifiers+tex_math_single_backslash
    preserve_yaml: TRUE
always_allow_html: yes   
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding,
  output_dir = "../../MuestreoySeriesdeTiempo/_posts/", output_format = "all"  ) })
bibliography: "../../referencias.bib"
csl: "../../apa.csl"
link-citations: yes
---

```{r knitr_init, echo=FALSE, cache=FALSE}
library(knitr)
## Global options
opts_chunk$set(echo=TRUE,
               cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE,
               fig.path = paste0("../../MuestreoySeriesdeTiempo/images/", "Clase08"),
               cache.path = "../../MuestreoySeriesdeTiempo/cache/",
               cache = FALSE)
```

<!-- AGREGAR FORMULAS PARA PRONÓSTICO ROMARIO SECCIÓN 6!!! -->

## Operador de rezagos
El operador de rezagos es un término usado en series de tiempo, para operar la serie de tiempo de interés, y obtener una serie rezagada o retardada un periodo hacia atrás, en donde al aplicar dicho operador varias veces, es posible obtener la serie rezagada o retardada `$p$` periodos hacia atrás.

Por tanto, si denotamos al operador de rezagos como `$L$`, tendremos que `$L(Y_t)=Y_{t-1}$`, en donde se observa que la función `$L$` rezaga la serie original en una observación. En general si aplicamos la función `$L$` un total de `$p=1,2,\ldots$` veces, se tendrá 
`\begin{align*}
L(Y_t)=Y_{t-1} \\
L^2(Y_t)=Y_{t-2} \\
\vdots \quad \quad \quad \\
L^p(Y_t)=Y_{t-p}
\end{align*}`
Además, para el caso particular en que `$p=0$`, se tendrá que `$L^0=I$`, donde `$I$` se conoce como la función identidad.

Sea ahora, un polinomio de rezagos de orden `$p$` (un filtro lineal), el cual se aplica al operador de rezagos `$L$`, para obtener una combinación lineal de `$L$` de la forma
`\begin{align*}
B_p(L)=\beta_0I+\beta_1L+\beta_2L^2+\ldots+\beta_pL^p
\end{align*}`

donde cada `$\beta_j$` representa un valor constantes, con `$j=0,1, \ldots, p$`, y en donde, se observa que la ecuación anterior define un polinomio de orden `$p$` en `$L$`, el cual, al ser multiplicado por la serie `$Y_t$` se obtendrá que
`\begin{align*}
B_p(L)(Y_t) & = (\beta_0I+\beta_1L+\beta_2L^2+\ldots+\beta_pL^p)(Y_t) \\
            & = \beta_0I(Y_t)+\beta_1L(Y_t)+\beta_2L^2(Y_t)+\ldots+\beta_pL^p(Y_t) \\
            & = \sum_{j=0}^p\beta_jL^j(Y_t) \\
            & = \sum_{j=0}^p\beta_jY_{t-j} \\
            & = \beta_0Y_t+\beta_1Y_{t-2}+\beta_2Y_{t-2}+\ldots+\beta_pY_{t-p}
\end{align*}`

## Modelos de medias móviles (MA)
@Guerrero2003[, pp. 80-81]  se introduce a los modelos de medias móviles como un proceso estocástico `$\{Yt\}$`, cuyos valores pueden ser dependientes unos de otros, como una suma finita ponderada de choques aleatorios independientes `$\{\varepsilon_t\}$`. En donde, el término de medias móviles parece sugerir que el modelo se obtiene como un promedio de los choques aleatorios que intervienen, pero no es así, puesto que los parámetros no tienen que ser necesariamente positivos, ni su suma debe ser la unidad, como requeriría un promedio poderado.

### Proceso de media móvil de orden 1 o MA(1)
<!-- Una forma de entender los procesos de media móvil, es mediante el concepto de **juego de suma cero**. Suponga un juego que involucra lanzar una moneda, si sale cara se obtiene una ganancia de `$G$`, mientras que si sale sello se obtiene una pérdida de `$G$`, es decir, el mismo monto. Dado esto, se tendrá que la ganancia promedio del juego será igual a `$0$`, y por tanto, la ganancia a obtener puede ser representada mediante un ruido blanco (`$\varepsilon_t$`) con media `$0$` y varianza `$\sigma^2$`. -->

<!-- Entonces, si queremos representar la ganancia `$Y_t$` obtenida en el juego, al lanzar una moneda se tendrá que -->
<!-- `\begin{align*} -->
<!-- Y_t = \beta_0\varepsilon_t -->
<!-- \end{align*}` -->
<!-- siendo \beta_0 la probabilidad de ocurrencia. Si se lanza la moneda dos veces, se tendrá que -->
<!-- `\begin{align*} -->
<!-- Y_t = \beta_0\varepsilon_t + \beta_1\varepsilon_{t-1} -->
<!-- \end{align*}` -->
<!-- siendo \beta_i la probabilidad de ocurrencia, en donde en este caso será igual a `$1/2$`, para `$i\leq 1$` y `$0$` para `$i>1$`. Si se lanza la moneda tres veces -->
<!-- `\begin{align*} -->
<!-- Y_t = \beta_0\varepsilon_t + \beta_1\varepsilon_{t-1} + \beta_2\varepsilon_{t-2} -->
<!-- \end{align*}` -->
<!-- siendo \beta_i la probabilidad de ocurrencia, en donde en este caso será igual a `$1/3$`, para `$i\leq 2$` y `$0$` para `$i>2$`, y así sucesivamente. Es de anotar, que en este caso, a pesar de que el proceso MA se encuentra integrado por puros `$\varepsilon_t$`,  -->

Se dice que `$\{Y_t\}_{t≥1}$` es un proceso de media móvil de orden 1, si podemos expresar a `$\widetilde{Y}_t = Y_t - \mu$` en términos de un proceso estacionario de media cero, tal que
`\begin{align*}
\widetilde{Y}_t & = (1+\theta_1 L)\varepsilon_t \\
    & = \varepsilon_t + \theta_1 L\varepsilon_t \\
    & = \varepsilon_t + \theta_1 \varepsilon_{t-1} 
\end{align*}`

De la ecuación anterior, se evidencia que un proceso MA(1) puede definirse como un operador de rezagos de un ruido blanco `$\varepsilon_t\sim(0,\sigma^2_{\varepsilon})$`, con `$\beta_1 = \theta_1$`, y `$\beta_j = 0$`, para `$j ≥ 2$`. Además, se puede probar que la media, varianza y autocovarianza del proceso MA(1), están dados por
`\begin{align*}
\mathbb{E}(\widetilde{Y}_t) & = 0 \\
Var(\widetilde{Y}_t) & =\gamma(0) = \sigma^2_{\varepsilon}(1+\theta_1^2) \\
Cov(\widetilde{Y}_t, \widetilde{Y}_{t+k}) & = \gamma(k) = \begin{cases} -\sigma_\varepsilon^2\theta_1 & 0\leq k=1 \\ 0 & k\geq 2\end{cases}
\end{align*}`

lo cual hace que el proceso MA(1) sea **siempre un proceso estacionario**, pero para ser invertible, se requiere que la raíz del polinomio de rezagos `$1+\theta_1 L =0$`caiga fuera del circulo unitario. Además, como el proceso MA(1) posee autocorrelacíones iguales a cero para rezagos `$k$` mayores a 1, se tendrá que el proceso MA(1) **no recuerda más allá de lo ocurrido en el período inmediatamente anterior**, es decír, tiene una memoria limitada a un solo período. 

Para la identificación de un proceso MA(1) es posible analizar las funciones ACF y PACF, y observar si se cumplen o no los siguientes comportamientos

```{r echo=FALSE}
library(kableExtra)
tabla1 <- rbind(c("MA(1)", "Solo el primer (1) coeficiente de autocorrelación es
significativo. El resto de coeficientes se anulan luego del primer rezago ($\\rho(k) = 0$ para retardo $k>1$)", "Decrecimiento rápido exponencial atenuado y/o en ondas sinusoidales."))
colnames(tabla1) = c("Proceso", "Función de autocorrelación (ACF)", "Función de autocorrelación parcial (PACF)")

kable(tabla1,
  format = "html", booktabs = T) %>%
kable_styling("striped", full_width = F) %>%
column_spec(1, width = "2cm") %>%
column_spec(2, width = "6cm") %>%
column_spec(3, width = "6cm") 
```

De lo anterior, es importante notar que aun cuando solamente la primera autocorrelación
es distinta de cero, dicha autocorrelación no puede ser elevada, ya que entre más elevada sea la autocorrelación se tendrá una dependencia más fuerte entre la observación actual con la anterior, y por tanto, se tendrá **la siguiente condición**
`\begin{align*}
|\rho_1|\leq 0.5
\end{align*}`

En consecuencia, **si una ACF posee un solo pico en la primera autocorrelación, se tendrá, que dicha ACF corresponderá a un proceso MA(1) solo cuando se satisface la condición anterior.**

A continuación, se realiza la simulación de tres escenarios para ilustrar el comportamiento de la ACF y la PACF de un proceso MA(1).
<pre>
```{r echo=FALSE}
library(htmltools)
library(plotly)
library(feasts)
library(tsibble)

############################## Sim 1 ##############################
set.seed(1420)
sim1 <- arima.sim(model=list(ma=-0.1, order =c(0,0,1)), n=100)
sim1a <- as_tsibble(sim1)
acfsim1 <- sim1a %>% ACF(value) # Calcula valores de ACF
pacfsim1 <- sim1a %>% PACF(value) # Calcula valores de PACF
CI <- function(x) qnorm((1 + 0.95)/2)/sqrt(sum(!is.na(x))) # Crea función para

plotacfsim1 <- plot_ly(acfsim1, width = 700, height = 400) %>%
  layout(title="ACF", xaxis = list(title ="Lags"), yaxis = list(title = "ACF")) %>% 
add_bars(x = ~acfsim1$lag, y = ~acfsim1$acf, width = 0.2, text = paste("ACF =", acfsim1$acf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(acfsim1), y0=CI(sim1a$value), y1=CI(sim1a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(acfsim1), y0=-CI(sim1a$value), y1=-CI(sim1a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

plotpacfsim1 <- plot_ly(pacfsim1, width = 700, height = 400) %>%
  layout(title="PACF", xaxis = list(title ="Lags"), yaxis = list(title = "PACF")) %>% 
add_bars(x = ~pacfsim1$lag, y = ~pacfsim1$pacf, width = 0.2, text = paste("PACF =", pacfsim1$pacf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(pacfsim1), y0=CI(sim1a$value), y1=CI(sim1a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(pacfsim1), y0=-CI(sim1a$value), y1=-CI(sim1a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

tagList(subplot(plotacfsim1, plotpacfsim1, nrows = 1, margin = 0.08) %>% 
  layout(title = "ACF y PACF de un proceso MA(1)",
         yaxis = list(title = "ACF"),
         yaxis2 = list(title = "PACF"),
         xaxis2 = list(title = "Lags"),
         margin = list(r=30, l=60, t=60, b=60, pad = 4),
         height = 400, showlegend = FALSE))

############################## Sim 2 ##############################
set.seed(1010)
sim2 <- arima.sim(model=list(ma=0.9, order =c(0,0,1)), n=100)
sim2a <- as_tsibble(sim2)
acfsim2 <- sim2a %>% ACF(value) # Calcula valores de ACF
pacfsim2 <- sim2a %>% PACF(value) # Calcula valores de PACF
CI <- function(x) qnorm((1 + 0.95)/2)/sqrt(sum(!is.na(x))) # Crea función para

plotacfsim2 <- plot_ly(acfsim2, width = 700, height = 400) %>%
  layout(title="ACF", xaxis = list(title ="Lags"), yaxis = list(title = "ACF")) %>% 
add_bars(x = ~acfsim2$lag, y = ~acfsim2$acf, width = 0.2, text = paste("ACF =", acfsim2$acf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(acfsim2), y0=CI(sim2a$value), y1=CI(sim2a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(acfsim2), y0=-CI(sim2a$value), y1=-CI(sim2a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

plotpacfsim2 <- plot_ly(pacfsim2, width = 700, height = 400) %>%
  layout(title="PACF", xaxis = list(title ="Lags"), yaxis = list(title = "PACF")) %>% 
add_bars(x = ~pacfsim2$lag, y = ~pacfsim2$pacf, width = 0.2, text = paste("PACF =", pacfsim2$pacf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(pacfsim2), y0=CI(sim2a$value), y1=CI(sim2a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(pacfsim2), y0=-CI(sim2a$value), y1=-CI(sim2a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

tagList(subplot(plotacfsim2, plotpacfsim2, nrows = 1, margin = 0.08) %>% 
  layout(title = "ACF y PACF de un proceso MA(1)",
         yaxis = list(title = "ACF"),
         yaxis2 = list(title = "PACF"),
         xaxis2 = list(title = "Lags"),
         margin = list(r=30, l=60, t=60, b=60, pad = 4),
         height = 400, showlegend = FALSE))

############################## Sim 3 ##############################
set.seed(1928)
sim3 <- arima.sim(model=list(ma=-0.7, order =c(0,0,1)), n=100)
sim3a <- as_tsibble(sim3)
acfsim3 <- sim3a %>% ACF(value) # Calcula valores de ACF
pacfsim3 <- sim3a %>% PACF(value) # Calcula valores de PACF
CI <- function(x) qnorm((1 + 0.95)/2)/sqrt(sum(!is.na(x))) # Crea función para

plotacfsim3 <- plot_ly(acfsim3, width = 700, height = 400) %>%
  layout(title="ACF", xaxis = list(title ="Lags"), yaxis = list(title = "ACF")) %>% 
add_bars(x = ~acfsim3$lag, y = ~acfsim3$acf, width = 0.2, text = paste("ACF =", acfsim3$acf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(acfsim3), y0=CI(sim3a$value), y1=CI(sim3a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(acfsim3), y0=-CI(sim3a$value), y1=-CI(sim3a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

plotpacfsim3 <- plot_ly(pacfsim3, width = 700, height = 400) %>%
  layout(title="PACF", xaxis = list(title ="Lags"), yaxis = list(title = "PACF")) %>% 
add_bars(x = ~pacfsim3$lag, y = ~pacfsim3$pacf, width = 0.2, text = paste("PACF =", pacfsim3$pacf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(pacfsim3), y0=CI(sim3a$value), y1=CI(sim3a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(pacfsim3), y0=-CI(sim3a$value), y1=-CI(sim3a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

tagList(subplot(plotacfsim3, plotpacfsim3, nrows = 1, margin = 0.08) %>% 
  layout(title = "ACF y PACF de un proceso MA(1)",
         yaxis = list(title = "ACF"),
         yaxis2 = list(title = "PACF"),
         xaxis2 = list(title = "Lags"),
         margin = list(r=30, l=60, t=60, b=60, pad = 4),
         height = 400, showlegend = FALSE))
```
</pre>

### Proceso de media móvil de orden q o MA(q)
Similar al proceso MA(1), se dice que `$\{Y_t\}_{t≥1}$` es un proceso de media móvil de orden q, si es posible expresar a `$\widetilde{Y}_t=Y_t-\mu$` en términos de un proceso estacionario en covarianza de media cero, tal que
`\begin{align*}
\widetilde{Y}_t & = (\Theta_q (L))\varepsilon_t \\
    & = (1 + \theta_1 L + \theta_2 L^2 + \ldots + \theta_q L^q) \varepsilon_t \\
    & = \varepsilon_t + \theta_1 L\varepsilon_t + \theta_2 L^2\varepsilon_t + \ldots + \theta_q L^q\varepsilon_t\\ 
    & = \varepsilon_t + \theta_1 \varepsilon_{t-1} + \theta_2 \varepsilon_{t-2} + \ldots + \theta_q \varepsilon_{t-q}
\end{align*}`

En este caso, el proceso MA(q) puede definirse como una generalización del proceso MA(1), el cual posee una media, varianza y correlación dados por

`\begin{align*}
\mathbb{E}(\widetilde{Y}_t) & = 0 \\
Var(\widetilde{Y}_t) & = \gamma(0) = \sigma^2_{\varepsilon}(1+\theta_1^2+\theta_2^2+\ldots+\theta_q^2) \\
Cov(\widetilde{Y}_t, \widetilde{Y}_{t+k}) & = \gamma(k) = \begin{cases} \sigma_\varepsilon^2 \sum_{j=0}^{q-k}\theta_j\theta_{j+k} & 0\leq k\leq q \\ 0 & k\geq q+1\end{cases}
\end{align*}`

con `$\theta_0 = 1$` y donde se observa que `$Var(\widetilde{Y}_t)>Var(\varepsilon_t)=\sigma_\varepsilon^2$`. Por consiguiente, se tendrá que **todo proceso MA(q) será un proceso estacionario**, pero para ser invertible, se requiere que la raíz del polinomio de rezagos `$(\Theta_1 (L))$` caiga fuera del circulo unitario. Además, el proceso MA(q) tendrá una **memoria limitada a q periodos**, ya que, para rezagos `$k$` mayores a q, la autocorrelaciones serán iguales a 0.

En @Guerrero2003[, p. 81]  el autor define a los procesos MA como un proceso en equilibrio, en donde las fluctuaciones alrededor del punto de equilibrio, `${\widetilde{Y}_t}_{t≥1}$`, son causadas por choques asociados a eventos inesperados. Tales choques no necesariamente se asimilan de manera instantánea, sino que pueden seguir causando efectos aún después de transcurrido cierto número de períodos y además la intensidad del choque se refleja en el valor de su ponderación `$\theta_j$`.

Para la identificación de un proceso MA(q) es posible analizar las funciones ACF y PACF, y observar si se cumplen o no los siguientes comportamientos

```{r echo=FALSE}
library(kableExtra)
tabla1 <- rbind(c("MA(q)", "Solo los q primeros coeficientes de autocorrelación son
significativos. El resto de coeficientes se anulan luego del q-ésimo rezago ($\\rho(k) = 0$ para retardo $k>q$)", "Decrecimiento rápido exponencial atenuado y/o en ondas sinusoidales."))
colnames(tabla1) = c("Proceso", "Función de autocorrelación (ACF)", "Función de autocorrelación parcial (PACF)")

kable(tabla1,
  format = "html", booktabs = T) %>%
kable_styling("striped", full_width = F) %>%
column_spec(1, width = "2cm") %>%
column_spec(2, width = "6cm") %>%
column_spec(3, width = "6cm") 
```

Similar al caso MA(1), es posible encontrar las restricciones o condiciones que deben cumplir las autocorrelación, para que los picos obtenidos de la ACF correspondan a un proceso MA(q). Dicha condición está dada por  <!-- Citar Davies, Pate y Frost (1974) -->
`\begin{align*}
|\rho_k|\leq \begin{cases}cos(\pi/(M+1)) & \text{ si } k \text{ es divisor de } q+1 \\ cos(\pi/(M+2)) & \text{ si } k \text{ no es divisor de } q+1 \end{cases}
\end{align*}`

donde `$M$` es el mayor entero menor o igual a `$(q+1)/k$`.

A continuación, se realiza la simulación de tres escenarios para ilustrar el comportamiento de la ACF y la PACF de un proceso MA(q).
<pre>
```{r echo=FALSE}
############################## Sim 4 ##############################
set.seed(225)
sim4 <- arima.sim(model=list(ma=c(0.8, 0.9, 4), order =c(0,0,3)), n=100)
sim4a <- as_tsibble(sim4)
acfsim4 <- sim4a %>% ACF(value) # Calcula valores de ACF
pacfsim4 <- sim4a %>% PACF(value) # Calcula valores de PACF
CI <- function(x) qnorm((1 + 0.95)/2)/sqrt(sum(!is.na(x))) # Crea función para

plotacfsim4 <- plot_ly(acfsim4, width = 700, height = 400) %>%
  layout(title="ACF", xaxis = list(title ="Lags"), yaxis = list(title = "ACF")) %>% 
add_bars(x = ~acfsim4$lag, y = ~acfsim4$acf, width = 0.2, text = paste("ACF =", acfsim4$acf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(acfsim4), y0=CI(sim4a$value), y1=CI(sim4a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(acfsim4), y0=-CI(sim4a$value), y1=-CI(sim4a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

plotpacfsim4 <- plot_ly(pacfsim4, width = 700, height = 400) %>%
  layout(title="PACF", xaxis = list(title ="Lags"), yaxis = list(title = "PACF")) %>% 
add_bars(x = ~pacfsim4$lag, y = ~pacfsim4$pacf, width = 0.2, text = paste("PACF =", pacfsim4$pacf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(pacfsim4), y0=CI(sim4a$value), y1=CI(sim4a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(pacfsim4), y0=-CI(sim4a$value), y1=-CI(sim4a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

tagList(subplot(plotacfsim4, plotpacfsim4, nrows = 1, margin = 0.08) %>% 
  layout(title = "ACF y PACF de un proceso MA(3)",
         yaxis = list(title = "ACF"),
         yaxis2 = list(title = "PACF"),
         xaxis2 = list(title = "Lags"),
         margin = list(r=30, l=60, t=60, b=60, pad = 4),
         height = 400, showlegend = FALSE))

############################## Sim 5 ##############################
set.seed(1010)
sim5 <- arima.sim(model=list(ma=c(0.9, 0.7), order =c(0,0,2)), n=100)
sim5a <- as_tsibble(sim5)
acfsim5 <- sim5a %>% ACF(value) # Calcula valores de ACF
pacfsim5 <- sim5a %>% PACF(value) # Calcula valores de PACF
CI <- function(x) qnorm((1 + 0.95)/2)/sqrt(sum(!is.na(x))) # Crea función para

plotacfsim5 <- plot_ly(acfsim5, width = 700, height = 400) %>%
  layout(title="ACF", xaxis = list(title ="Lags"), yaxis = list(title = "ACF")) %>% 
add_bars(x = ~acfsim5$lag, y = ~acfsim5$acf, width = 0.2, text = paste("ACF =", acfsim5$acf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(acfsim5), y0=CI(sim5a$value), y1=CI(sim5a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(acfsim5), y0=-CI(sim5a$value), y1=-CI(sim5a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

plotpacfsim5 <- plot_ly(pacfsim5, width = 700, height = 400) %>%
  layout(title="PACF", xaxis = list(title ="Lags"), yaxis = list(title = "PACF")) %>% 
add_bars(x = ~pacfsim5$lag, y = ~pacfsim5$pacf, width = 0.2, text = paste("PACF =", pacfsim5$pacf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(pacfsim5), y0=CI(sim5a$value), y1=CI(sim5a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(pacfsim5), y0=-CI(sim5a$value), y1=-CI(sim5a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

tagList(subplot(plotacfsim5, plotpacfsim5, nrows = 1, margin = 0.08) %>% 
  layout(title = "ACF y PACF de un proceso MA(2)",
         yaxis = list(title = "ACF"),
         yaxis2 = list(title = "PACF"),
         xaxis2 = list(title = "Lags"),
         margin = list(r=30, l=60, t=60, b=60, pad = 4),
         height = 400, showlegend = FALSE))

############################## Sim 6 ##############################
set.seed(1628)
sim6 <- arima.sim(model=list(ma=c(0.6, 0.3, 0.25, 0.45), order =c(0,0,4)), n=100)
sim6a <- as_tsibble(sim6)
acfsim6 <- sim6a %>% ACF(value) # Calcula valores de ACF
pacfsim6 <- sim6a %>% PACF(value) # Calcula valores de PACF
CI <- function(x) qnorm((1 + 0.95)/2)/sqrt(sum(!is.na(x))) # Crea función para

plotacfsim6 <- plot_ly(acfsim6, width = 700, height = 400) %>%
  layout(title="ACF", xaxis = list(title ="Lags"), yaxis = list(title = "ACF")) %>% 
add_bars(x = ~acfsim6$lag, y = ~acfsim6$acf, width = 0.2, text = paste("ACF =", acfsim6$acf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(acfsim6), y0=CI(sim6a$value), y1=CI(sim6a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(acfsim6), y0=-CI(sim6a$value), y1=-CI(sim6a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

plotpacfsim6 <- plot_ly(pacfsim6, width = 700, height = 400) %>%
  layout(title="PACF", xaxis = list(title ="Lags"), yaxis = list(title = "PACF")) %>% 
add_bars(x = ~pacfsim6$lag, y = ~pacfsim6$pacf, width = 0.2, text = paste("PACF =", pacfsim6$pacf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(pacfsim6), y0=CI(sim6a$value), y1=CI(sim6a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(pacfsim6), y0=-CI(sim6a$value), y1=-CI(sim6a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

tagList(subplot(plotacfsim6, plotpacfsim6, nrows = 1, margin = 0.08) %>% 
  layout(title = "ACF y PACF de un proceso MA(4)",
         yaxis = list(title = "ACF"),
         yaxis2 = list(title = "PACF"),
         xaxis2 = list(title = "Lags"),
         margin = list(r=30, l=60, t=60, b=60, pad = 4),
         height = 400, showlegend = FALSE))
```
</pre>

## Modelos autorregresivos (AR)
Los procesos autorregresivos son un tipo de proceso estocástico en el cual
el valor actual de una serie está linealmente relacionado con sus valores pasados
más una perturbación o choque aleatorio aditivo.

### Modelos autorregresivos de orden 1 o AR(1)
Se dice que `$\{Y_t\}_{t≥1}$` sigue un proceso de autorregresivo de orden 1 con media cero, si podemos expresar a `$\widetilde{Y} = Y_t - \mu$` en términos de un proceso estacionario de media cero, tal que
`\begin{align*}
(1 - \phi_1 L)\widetilde{Y}_t & = \varepsilon_t \\
\widetilde{Y}_t - \phi_1 L\widetilde{Y}_t & = \varepsilon_t \\
\widetilde{Y}_t - \phi_1 \widetilde{Y}_{t-1} & = \varepsilon_t \\
\widetilde{Y}_t & = \phi_1 \widetilde{Y}_{t-1} + \varepsilon_t
\end{align*}`

con `$\varepsilon_t\sim RB(0, \sigma_{\varepsilon}^2)$` independiente de `$\widetilde{Y}_{t+k}$` para todo `$k>0$`. De la ecuación anterior, se observa que se tiene una estructura de regresión entre `$\widetilde{Y}_t$` y `$\widetilde{Y}_{t-1}$`, lo cual indica **existe una relación lineal entre las observaciones y los valores de la misma rezagadas un periodo**, siendo el parámetro `$\phi_1$` el parámetro del modelo.

Además, se puede probar que la media, varianza y autocovarianza del proceso AR(1), bajo el supuesto `$|\phi_1|<1$` están dados por
`\begin{align*}
\mathbb{E}(\widetilde{Y}_t) & = 0 \\
Var(\widetilde{Y}_t) & =\gamma(0) = \frac{\sigma^2_{\varepsilon}}{(1-\phi_1^2)} & \text { para } k  = 0, \pm 1, \pm 2, \ldots \\
Cov(\widetilde{Y}_t, \widetilde{Y}_{t+k}) & = \gamma(k) = \phi^k \left(\frac{\sigma^2_\varepsilon}{1-\phi_1^2}\right) & \text { para } k  = 0, \pm 1, \pm 2, \ldots
\end{align*}`

lo cual indica que, a medida que `$k > 0$` crece, la ACF debe tender a cero, con decaimiento del tipo exponencial cuando `$0<\phi<1$` y con signos alternados cuando `$-1 < \phi < 0$`. La condición `$|\phi|<1$` es requerida para que la serie sea estacionaria en covarianza, ya que **ésto garantiza que la raíz del polinomio de rezagos caiga fuera del círculo unitario**. Adicionalmente, y a diferencia del modelo MA(q), se tiene que **todo proceso AR(1) es invertible**.

Para la identificación de un proceso AR(1) es posible analizar las funciones ACF y PACF, y observar si se cumplen o no los siguientes comportamientos

```{r echo=FALSE}
library(kableExtra)
tabla1 <- rbind(c("AR(1)", "Decrecimiento rápido exponencial atenuado y/o en ondas sinusoidales.", "Solo el primer (1) coeficientes de autocorrelación parcial es
significativos. El resto de coeficientes se anulan luego del primer rezago ($\\phi_{kk} = 0$ para retardo $k>1$)"))
colnames(tabla1) = c("Proceso", "Función de autocorrelación (ACF)", "Función de autocorrelación parcial (PACF)")

kable(tabla1,
  format = "html", booktabs = T) %>%
kable_styling("striped", full_width = F) %>%
column_spec(1, width = "2cm") %>%
column_spec(2, width = "6cm") %>%
column_spec(3, width = "6cm") 
```

A continuación, se realiza la simulación de tres escenarios para ilustrar el comportamiento de la ACF y la PACF de un proceso AR(1).
<pre>
```{r echo=FALSE}
############################## Sim 7 ##############################
set.seed(2225)
sim7 <- arima.sim(model=list(ar=-0.4, order =c(1,0,0)), n=100)
sim7a <- as_tsibble(sim7)
acfsim7 <- sim7a %>% ACF(value) # Calcula valores de ACF
pacfsim7 <- sim7a %>% PACF(value) # Calcula valores de PACF
CI <- function(x) qnorm((1 + 0.95)/2)/sqrt(sum(!is.na(x))) # Crea función para

plotacfsim7 <- plot_ly(acfsim7, width = 700, height = 400) %>%
  layout(title="ACF", xaxis = list(title ="Lags"), yaxis = list(title = "ACF")) %>% 
add_bars(x = ~acfsim7$lag, y = ~acfsim7$acf, width = 0.2, text = paste("ACF =", acfsim7$acf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(acfsim7), y0=CI(sim7a$value), y1=CI(sim7a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(acfsim7), y0=-CI(sim7a$value), y1=-CI(sim7a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

plotpacfsim7 <- plot_ly(pacfsim7, width = 700, height = 400) %>%
  layout(title="PACF", xaxis = list(title ="Lags"), yaxis = list(title = "PACF")) %>% 
add_bars(x = ~pacfsim7$lag, y = ~pacfsim7$pacf, width = 0.2, text = paste("PACF =", pacfsim7$pacf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(pacfsim7), y0=CI(sim7a$value), y1=CI(sim7a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(pacfsim7), y0=-CI(sim7a$value), y1=-CI(sim7a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

tagList(subplot(plotacfsim7, plotpacfsim7, nrows = 1, margin = 0.08) %>% 
  layout(title = "ACF y PACF de un proceso AR(1)",
         yaxis = list(title = "ACF"),
         yaxis2 = list(title = "PACF"),
         xaxis2 = list(title = "Lags"),
         margin = list(r=30, l=60, t=60, b=60, pad = 4),
         height = 400, showlegend = FALSE))

############################## Sim 8 ##############################
set.seed(1613)
sim8 <- arima.sim(model=list(ar=0.7, order =c(1,0,0)), n=100)
sim8a <- as_tsibble(sim8)
acfsim8 <- sim8a %>% ACF(value) # Calcula valores de ACF
pacfsim8 <- sim8a %>% PACF(value) # Calcula valores de PACF
CI <- function(x) qnorm((1 + 0.95)/2)/sqrt(sum(!is.na(x))) # Crea función para

plotacfsim8 <- plot_ly(acfsim8, width = 700, height = 400) %>%
  layout(title="ACF", xaxis = list(title ="Lags"), yaxis = list(title = "ACF")) %>% 
add_bars(x = ~acfsim8$lag, y = ~acfsim8$acf, width = 0.2, text = paste("ACF =", acfsim8$acf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(acfsim8), y0=CI(sim8a$value), y1=CI(sim8a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(acfsim8), y0=-CI(sim8a$value), y1=-CI(sim8a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

plotpacfsim8 <- plot_ly(pacfsim8, width = 700, height = 400) %>%
  layout(title="PACF", xaxis = list(title ="Lags"), yaxis = list(title = "PACF")) %>% 
add_bars(x = ~pacfsim8$lag, y = ~pacfsim8$pacf, width = 0.2, text = paste("PACF =", pacfsim8$pacf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(pacfsim8), y0=CI(sim8a$value), y1=CI(sim8a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(pacfsim8), y0=-CI(sim8a$value), y1=-CI(sim8a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

tagList(subplot(plotacfsim8, plotpacfsim8, nrows = 1, margin = 0.08) %>% 
  layout(title = "ACF y PACF de un proceso AR(1)",
         yaxis = list(title = "ACF"),
         yaxis2 = list(title = "PACF"),
         xaxis2 = list(title = "Lags"),
         margin = list(r=30, l=60, t=60, b=60, pad = 4),
         height = 400, showlegend = FALSE))

############################## Sim 9 ##############################
set.seed(2276)
sim9 <- arima.sim(model=list(ar=-0.6, order =c(1,0,0)), n=100)
sim9a <- as_tsibble(sim9)
acfsim9 <- sim9a %>% ACF(value) # Calcula valores de ACF
pacfsim9 <- sim9a %>% PACF(value) # Calcula valores de PACF
CI <- function(x) qnorm((1 + 0.95)/2)/sqrt(sum(!is.na(x))) # Crea función para

plotacfsim9 <- plot_ly(acfsim9, width = 700, height = 400) %>%
  layout(title="ACF", xaxis = list(title ="Lags"), yaxis = list(title = "ACF")) %>% 
add_bars(x = ~acfsim9$lag, y = ~acfsim9$acf, width = 0.2, text = paste("ACF =", acfsim9$acf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(acfsim9), y0=CI(sim9a$value), y1=CI(sim9a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(acfsim9), y0=-CI(sim9a$value), y1=-CI(sim9a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

plotpacfsim9 <- plot_ly(pacfsim9, width = 700, height = 400) %>%
  layout(title="PACF", xaxis = list(title ="Lags"), yaxis = list(title = "PACF")) %>% 
add_bars(x = ~pacfsim9$lag, y = ~pacfsim9$pacf, width = 0.2, text = paste("PACF =", pacfsim9$pacf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(pacfsim9), y0=CI(sim9a$value), y1=CI(sim9a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(pacfsim9), y0=-CI(sim9a$value), y1=-CI(sim9a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

tagList(subplot(plotacfsim9, plotpacfsim9, nrows = 1, margin = 0.08) %>% 
  layout(title = "ACF y PACF de un proceso AR(1)",
         yaxis = list(title = "ACF"),
         yaxis2 = list(title = "PACF"),
         xaxis2 = list(title = "Lags"),
         margin = list(r=30, l=60, t=60, b=60, pad = 4),
         height = 400, showlegend = FALSE))
```
</pre>

### Modelos autorregresivos de orden p o AR(p)
Se dice que `$\{Y_t\}_{t≥1}$` sigue un proceso de autorregresivo de orden p con media cero, si podemos expresar a `$\widetilde{Y} = Y_t - \mu$` en términos de un proceso estacionario de media cero, tal que
`\begin{align*}
(\Phi_p (L))\widetilde{Y}_t & = \varepsilon_t \\
(1 - \phi_1 (L) - \phi_2 L^2 - \ldots - \phi_p L^p)\widetilde{Y}_t & = \varepsilon_t \\
\widetilde{Y}_t - \phi_1 L \widetilde{Y}_t - \phi_2 L^2 \widetilde{Y}_t - \ldots - \phi_p L^p \widetilde{Y}_t & = \varepsilon_t \\
\widetilde{Y}_t - \phi_1 \widetilde{Y}_{t-1} - \phi_2 \widetilde{Y}_{t-2} - \ldots - \phi_p \widetilde{Y}_{t-p} & = \varepsilon_t \\
\widetilde{Y}_t & = \phi_1 \widetilde{Y}_{t-1} + \phi_2 \widetilde{Y}_{t-2} + \ldots + \phi_p \widetilde{Y}_{t-p} + \varepsilon_t
\end{align*}`

con `$\varepsilon_t\sim R.B(0, \sigma_{\varepsilon}^2)$` independiente de `$\widetilde{Y}_{t+k}$` para todo `$k>0$`. Similar al proceso AR(1), se observa que se tiene una estructura de regresión entre `$\widetilde{Y}_t$` y `$\widetilde{Y}_{t-j}$`, con `$j = 1,2, \ldots, p$` lo cual indica que **existe una relación lineal entre las observaciones y los p periodos pasados de la misma variable**.

Adicionalmente, para garantizar que el modelo AR(p) sea estacionario, **se requiere que el polinomio de rezagos `$(\Phi_p L)=0$`**, con el fin de que su modulo caiga fuera del circulo unitario. Por otro lado, se tiene que **todo proceso AR(p) es invertible**.

La media, varianza y autocovarianza del proceso AR(p), bajo la condición de estacionaridad, se obtienen mediante las ecuaciones
`\begin{align*}
\mathbb{E}(\widetilde{Y}_t) & = 0 \\
Var(\widetilde{Y}_t) & =\gamma(0) = \sum_{k=1}^p \phi_k \gamma(k) + \gamma_\varepsilon^2 & \text { para } k  = 0, \pm 1, \pm 2, \ldots \\
Cov(\widetilde{Y}_t, \widetilde{Y}_{t+k}) & = \mathbb{E}(Y_tY_{t-k}) & \text{ para } k  = 0, \pm 1, \pm 2, \ldots
\end{align*}`

Para la identificación de un proceso AR(p) es posible analizar las funciones ACF y PACF, y observar si se cumplen o no los siguientes comportamientos

```{r echo=FALSE}
library(kableExtra)
tabla1 <- rbind(c("AR(p)", "Decrecimiento rápido exponencial atenuado y/o en ondas sinusoidales.", "Solo los p primeros coeficientes de autocorrelación parcial son
significativos. El resto de coeficientes se anulan luego del p-ésimo rezago ($\\phi_{kk} = 0$ para retardo $k>p$)"))
colnames(tabla1) = c("Proceso", "Función de autocorrelación (ACF)", "Función de autocorrelación parcial (PACF)")

kable(tabla1,
  format = "html", booktabs = T) %>%
kable_styling("striped", full_width = F) %>%
column_spec(1, width = "2cm") %>%
column_spec(2, width = "6cm") %>%
column_spec(3, width = "6cm") 
```

A continuación, se realiza la simulación de tres escenarios para ilustrar el comportamiento de la ACF y la PACF de un proceso AR(p).
<pre>
```{r echo=FALSE}
############################## Sim 10 ##############################
set.seed(1227)
sim10 <- arima.sim(model=list(ar=c(-0.6,0.4,0.5,0.4), order =c(4,0,0)), n=100)
sim10a <- as_tsibble(sim10)
acfsim10 <- sim10a %>% ACF(value) # Calcula valores de ACF
pacfsim10 <- sim10a %>% PACF(value) # Calcula valores de PACF
CI <- function(x) qnorm((1 + 0.95)/2)/sqrt(sum(!is.na(x))) # Crea función para

plotacfsim10 <- plot_ly(acfsim10, width = 700, height = 400) %>%
  layout(title="ACF", xaxis = list(title ="Lags"), yaxis = list(title = "ACF")) %>% 
add_bars(x = ~acfsim10$lag, y = ~acfsim10$acf, width = 0.2, text = paste("ACF =", acfsim10$acf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(acfsim10), y0=CI(sim10a$value), y1=CI(sim10a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(acfsim10), y0=-CI(sim10a$value), y1=-CI(sim10a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

plotpacfsim10 <- plot_ly(pacfsim10, width = 700, height = 400) %>%
  layout(title="PACF", xaxis = list(title ="Lags"), yaxis = list(title = "PACF")) %>% 
add_bars(x = ~pacfsim10$lag, y = ~pacfsim10$pacf, width = 0.2, text = paste("PACF =", pacfsim10$pacf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(pacfsim10), y0=CI(sim10a$value), y1=CI(sim10a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(pacfsim10), y0=-CI(sim10a$value), y1=-CI(sim10a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

tagList(subplot(plotacfsim10, plotpacfsim10, nrows = 1, margin = 0.08) %>% 
  layout(title = "ACF y PACF de un proceso AR(4)",
         yaxis = list(title = "ACF"),
         yaxis2 = list(title = "PACF"),
         xaxis2 = list(title = "Lags"),
         margin = list(r=30, l=60, t=60, b=60, pad = 4),
         height = 400, showlegend = FALSE))

############################## Sim 11 ##############################
set.seed(1817)
sim11 <- arima.sim(model=list(ar=c(0.4,0.5), order =c(2,0,0)), n=100)
sim11a <- as_tsibble(sim11)
acfsim11 <- sim11a %>% ACF(value) # Calcula valores de ACF
pacfsim11 <- sim11a %>% PACF(value) # Calcula valores de PACF
CI <- function(x) qnorm((1 + 0.95)/2)/sqrt(sum(!is.na(x))) # Crea función para

plotacfsim11 <- plot_ly(acfsim11, width = 700, height = 400) %>%
  layout(title="ACF", xaxis = list(title ="Lags"), yaxis = list(title = "ACF")) %>% 
add_bars(x = ~acfsim11$lag, y = ~acfsim11$acf, width = 0.2, text = paste("ACF =", acfsim11$acf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(acfsim11), y0=CI(sim11a$value), y1=CI(sim11a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(acfsim11), y0=-CI(sim11a$value), y1=-CI(sim11a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

plotpacfsim11 <- plot_ly(pacfsim11, width = 700, height = 400) %>%
  layout(title="PACF", xaxis = list(title ="Lags"), yaxis = list(title = "PACF")) %>% 
add_bars(x = ~pacfsim11$lag, y = ~pacfsim11$pacf, width = 0.2, text = paste("PACF =", pacfsim11$pacf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(pacfsim11), y0=CI(sim11a$value), y1=CI(sim11a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(pacfsim11), y0=-CI(sim11a$value), y1=-CI(sim11a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

tagList(subplot(plotacfsim11, plotpacfsim11, nrows = 1, margin = 0.08) %>% 
  layout(title = "ACF y PACF de un proceso AR(2)",
         yaxis = list(title = "ACF"),
         yaxis2 = list(title = "PACF"),
         xaxis2 = list(title = "Lags"),
         margin = list(r=30, l=60, t=60, b=60, pad = 4),
         height = 400, showlegend = FALSE))

############################## Sim 12 ##############################
set.seed(1625)
sim12 <- arima.sim(model=list(ar=c(0.4,0.3, -0.3), order =c(3,0,0)), n=100)
sim12a <- as_tsibble(sim12)
acfsim12 <- sim12a %>% ACF(value) # Calcula valores de ACF
pacfsim12 <- sim12a %>% PACF(value) # Calcula valores de PACF
CI <- function(x) qnorm((1 + 0.95)/2)/sqrt(sum(!is.na(x))) # Crea función para

plotacfsim12 <- plot_ly(acfsim12, width = 700, height = 400) %>%
  layout(title="ACF", xaxis = list(title ="Lags"), yaxis = list(title = "ACF")) %>% 
add_bars(x = ~acfsim12$lag, y = ~acfsim12$acf, width = 0.2, text = paste("ACF =", acfsim12$acf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(acfsim12), y0=CI(sim12a$value), y1=CI(sim12a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(acfsim12), y0=-CI(sim12a$value), y1=-CI(sim12a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

plotpacfsim12 <- plot_ly(pacfsim12, width = 700, height = 400) %>%
  layout(title="PACF", xaxis = list(title ="Lags"), yaxis = list(title = "PACF")) %>% 
add_bars(x = ~pacfsim12$lag, y = ~pacfsim12$pacf, width = 0.2, text = paste("PACF =", pacfsim12$pacf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(pacfsim12), y0=CI(sim12a$value), y1=CI(sim12a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(pacfsim12), y0=-CI(sim12a$value), y1=-CI(sim12a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

tagList(subplot(plotacfsim12, plotpacfsim12, nrows = 1, margin = 0.08) %>% 
  layout(title = "ACF y PACF de un proceso AR(3)",
         yaxis = list(title = "ACF"),
         yaxis2 = list(title = "PACF"),
         xaxis2 = list(title = "Lags"),
         margin = list(r=30, l=60, t=60, b=60, pad = 4),
         height = 400, showlegend = FALSE))
```
</pre>

## Condiciones de invertibilidad y estacionaridad
Dado que los métodos Box-Jenkins requieren que la serie sea un proceso estacionario e invertible, entonces debe probarse que se cumplan las dos condiciones cuando se tiene un modelo AR o uno MA.

### Condición de invertibilidad del proceso MA(q)
<!-- Modificar ya que es tomado de Norman -->
Suponga que se tiene que `$\widetilde{Y}\sim MA(q)$`, entonces `$\widetilde{Y}$` puede ser escrito como
`\begin{align*}
\widetilde{Y}_t & = \varepsilon_t + \theta_1 \varepsilon_{t-1} + \theta_2 \varepsilon_{t-2} + \ldots + \theta_q \varepsilon_{t-q}
\end{align*}`
donde
`\begin{align*}
\Theta (L) = (1 + \theta_1 L + \theta_2 L^2 + \ldots + \theta_q L^q)
\end{align*}`

entonces, si las raíces de `$\Theta (z) = 0$`, con `$z_1, z_2, \ldots, z_q$` cumplen 
`\begin{align*}
|z_i|>1 \text{ con } i = 1, 2 . . . , q
\end{align*}`

**se dice que `$\widetilde{Y}_t$` es invertible**. En <tt>R</tt> puede emplearse la función `polyroot()` para el cálculo de la raíz del polinomio y la función `Mod()` para el cálculo del módulo de la raíz del polinomio. si el resultado es mayor a 1, entonces `$\widetilde{Y}_t$` es invertible. Además, como se señaló previamente, **un proceso de medias móviles siempre es estacionario!**
<!-- Ver ejercicio norman pag 147 y pag 123-124 -->

### Condición de estacionaridad del proceso AR(p)
<!-- Modificar ya que es tomado de Norman -->
Suponga que se tiene que `$\widetilde{Y}\sim AR(p)$`, entonces `$\widetilde{Y}$` puede ser escrito como
`\begin{align*}
\widetilde{Y}_t & = \phi_1 \widetilde{Y}_{t-1} + \phi_2 \widetilde{Y}_{t-2} + \ldots + \phi_p \widetilde{Y}_{t-p} + \varepsilon_t
\end{align*}`

donde
`\begin{align*}
(\Phi_p L) = (1 - \phi_1 L - \phi_2 L^2 - \ldots - \phi_p L^p) 
\end{align*}`

entonces, si las raíces de `$\Phi_p(z) = 0$`, con `$z_1, z_2, \ldots, z_p$` cumplen 
`\begin{align*}
|z_i|>1 \text{ con } i = 1, 2 . . . , p
\end{align*}`

**se dice que `$\widetilde{Y}_t$` es estacionaria**. En <tt>R</tt> puede emplearse la función `polyroot()` para el cálculo de la raíz del polinomio y la función `Mod()` para el cálculo del módulo de la raíz del polinomio. si el resultado es mayor a 1, entonces `$\widetilde{Y}_t$` es estacionaria. Además, como se señaló previamente, **un proceso de autorregresivo siempre es invertible!**

## Modelos autorregresivos y de medias móviles o ARMA(p,q)
Lo modelos ARMA son conocidos como una generalización de los modelos AR y MA, pues consiste en combinar ambas clases de modelos para obtener lo que se conoce como
modelos autorregresivos de medias móviles.

Una forma sencilla de introducir los modelos ARMA(p,q), es partiendo de que `$\widetilde{Y}_t = Y_t - \mu \sim$`AR(p), y por tanto, éste puede ser escrito como
`\begin{align*}
\widetilde{Y}_t - \phi_1 \widetilde{Y}_{t-1} - \phi_2 \widetilde{Y}_{t-2} - \ldots - \phi_p \widetilde{Y}_{t-p}& = \varepsilon_t
\end{align*}`
donde `$\varepsilon_t\sim R.B(0,\sigma_\varepsilon^2)$`. Ahora, si se reemplaza `$\varepsilon_t$` por un proceso MA(q)
`\begin{align*}
Z_t= \varepsilon_t + \theta_1 \varepsilon_{t-1} + \theta_2 \varepsilon_{t-2} + \ldots + \theta_q \varepsilon_{t-q}
\end{align*}`
entonces, se tendrá que 
`\begin{align*}
\widetilde{Y}_t - \phi_1 \widetilde{Y}_{t-1} - \phi_2 \widetilde{Y}_{t-2} - \ldots - \phi_p \widetilde{Y}_{t-p}& = \varepsilon_t + \theta_1 \varepsilon_{t-1} + \theta_2 \varepsilon_{t-2} + \ldots + \theta_q \varepsilon_{t-q}
\end{align*}`

De lo anterior, se tiene que un proceso ARMA(p,q) se define como un modelo que combina las propiedades de memoria larga de los AR(p) con las propiedades de ruido débilmente autocorrelacionado de los MA(q), lo cual le da suficiente flexibilidad y parsimonia para representar una variedad grande de procesos estacionarios en covarianza.

En general, Se dice que `$\{Y_t\}_{t≥1}$` es un proceso de autoregresivo de media móvil de ordenes (p,q), si podemos expresar a `$\widetilde{Y}_t = Y_t - \mu$` en términos de un proceso estacionario de media cero, tal que
`\begin{align*}
\Phi_p (L)\widetilde{Y}_t = \Theta_q (L)\varepsilon_t
\end{align*}`

donde `$\Phi_p(z) = 1 - \sum_{j=1}^p\phi_j z^j$` y `$\Theta_q(z) = 1 + \sum_{j=1}^q\theta_j z^j$` son los polinomios de rezagos autorregresivo y de medias móviles, respectivamente.

Adicionalmente, dado que el modelo ARMA(p,q) se construye a partir de un modelo AR(p) y un modelo MA(q), se asume que **las condiciones de estacionariedad de la parte AR(p) y de invertibilidad de la parte MA(q) se cumplen para el modelo ARMA(p,q)**, es decir, se tendrá que las raíces de los polinomios `$\Phi_p(z)=0$` y `$\Theta_q(z)=0$` se encuentran por fuera del circulo unitario (es decir, tienen módulo mayor a uno). También, se asume que los dos polinomios no tienen raíces en común. Si estas dos condiciones se cumplen, se tendrá que el proceso ARMA(p,q) es identificable y estacionario. 

Para la identificación de un proceso AR(p) es posible analizar las funciones ACF y PACF, y observar si se cumplen o no los siguientes comportamientos

```{r echo=FALSE}
library(kableExtra)
tabla1 <- rbind(c("ARMA(p,q)", "Decrece a 0 luego del q-ésimo rezago (aproximadamente de forma exponencial atenuada y/o con ondas sinusoidales). El decaimiento a cero no sucede de forma rápida", "Decrece a 0 luego del q-ésimo rezago (aproximadamente de forma exponencial atenuada y/o con ondas sinusoidales). El decaimiento a cero no sucede de forma rápida"))
colnames(tabla1) = c("Proceso", "Función de autocorrelación (ACF)", "Función de autocorrelación parcial (PACF)")

kable(tabla1,
  format = "html", booktabs = T) %>%
kable_styling("striped", full_width = F) %>%
column_spec(1, width = "2cm") %>%
column_spec(2, width = "6cm") %>%
column_spec(3, width = "6cm") 
```

Similar al caso AR y MA, el análisis del ACF y PACF podría ayudar a identificar el tipo de proceso que siguen los datos, pero que en el caso ARMA, no será tan evidente los órdenes p y q del proceso. En consecuencia, debe quedar claro que el análisis de la ACF y la PACF no pretenden determinar los ordenes p y q exactos, si no que busca restringir el rango de valores reales que pueden tener p y q.

A continuación, se realiza la simulación de tres escenarios para ilustrar el comportamiento de la ACF y la PACF de un proceso AR(p).
<pre>
```{r echo=FALSE}
############################## Sim 13 ##############################
set.seed(3227)
sim13 <- arima.sim(model=list(ar=0.3, ma= 0.6, order =c(1,0,1)), n=100)
sim13a <- as_tsibble(sim13)
acfsim13 <- sim13a %>% ACF(value) # Calcula valores de ACF
pacfsim13 <- sim13a %>% PACF(value) # Calcula valores de PACF
CI <- function(x) qnorm((1 + 0.95)/2)/sqrt(sum(!is.na(x))) # Crea función para

plotacfsim13 <- plot_ly(acfsim13, width = 700, height = 400) %>%
  layout(title="ACF", xaxis = list(title ="Lags"), yaxis = list(title = "ACF")) %>% 
add_bars(x = ~acfsim13$lag, y = ~acfsim13$acf, width = 0.2, text = paste("ACF =", acfsim13$acf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(acfsim13), y0=CI(sim13a$value), y1=CI(sim13a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(acfsim13), y0=-CI(sim13a$value), y1=-CI(sim13a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

plotpacfsim13 <- plot_ly(pacfsim13, width = 700, height = 400) %>%
  layout(title="PACF", xaxis = list(title ="Lags"), yaxis = list(title = "PACF")) %>% 
add_bars(x = ~pacfsim13$lag, y = ~pacfsim13$pacf, width = 0.2, text = paste("PACF =", pacfsim13$pacf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(pacfsim13), y0=CI(sim13a$value), y1=CI(sim13a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(pacfsim13), y0=-CI(sim13a$value), y1=-CI(sim13a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

tagList(subplot(plotacfsim13, plotpacfsim13, nrows = 1, margin = 0.08) %>% 
  layout(title = "ACF y PACF de un proceso ARMA(1,1)",
         yaxis = list(title = "ACF"),
         yaxis2 = list(title = "PACF"),
         xaxis2 = list(title = "Lags"),
         margin = list(r=30, l=60, t=60, b=60, pad = 4),
         height = 400, showlegend = FALSE))

############################## Sim 14 ##############################
set.seed(3224)
sim14 <- arima.sim(model=list(ar=c(0.3,0.4,-0.3), ma= c(0.6,0.2), order =c(3,0,2)), n=100)
sim14a <- as_tsibble(sim14)
acfsim14 <- sim14a %>% ACF(value) # Calcula valores de ACF
pacfsim14 <- sim14a %>% PACF(value) # Calcula valores de PACF
CI <- function(x) qnorm((1 + 0.95)/2)/sqrt(sum(!is.na(x))) # Crea función para

plotacfsim14 <- plot_ly(acfsim14, width = 700, height = 400) %>%
  layout(title="ACF", xaxis = list(title ="Lags"), yaxis = list(title = "ACF")) %>% 
add_bars(x = ~acfsim14$lag, y = ~acfsim14$acf, width = 0.2, text = paste("ACF =", acfsim14$acf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(acfsim14), y0=CI(sim14a$value), y1=CI(sim14a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(acfsim14), y0=-CI(sim14a$value), y1=-CI(sim14a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

plotpacfsim14 <- plot_ly(pacfsim14, width = 700, height = 400) %>%
  layout(title="PACF", xaxis = list(title ="Lags"), yaxis = list(title = "PACF")) %>% 
add_bars(x = ~pacfsim14$lag, y = ~pacfsim14$pacf, width = 0.2, text = paste("PACF =", pacfsim14$pacf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(pacfsim14), y0=CI(sim14a$value), y1=CI(sim14a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(pacfsim14), y0=-CI(sim14a$value), y1=-CI(sim14a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

tagList(subplot(plotacfsim14, plotpacfsim14, nrows = 1, margin = 0.08) %>% 
  layout(title = "ACF y PACF de un proceso ARMA(3,2)",
         yaxis = list(title = "ACF"),
         yaxis2 = list(title = "PACF"),
         xaxis2 = list(title = "Lags"),
         margin = list(r=30, l=60, t=60, b=60, pad = 4),
         height = 400, showlegend = FALSE))

############################## Sim 15 ##############################
set.seed(2114)
sim15 <- arima.sim(model=list(ar=c(-0.3, -0.2), ma= c(0.8, -0.7, -0.4), order =c(2,0,3)), n=100)
sim12a <- as_tsibble(sim12)
acfsim12 <- sim12a %>% ACF(value) # Calcula valores de ACF
pacfsim12 <- sim12a %>% PACF(value) # Calcula valores de PACF
CI <- function(x) qnorm((1 + 0.95)/2)/sqrt(sum(!is.na(x))) # Crea función para

plotacfsim12 <- plot_ly(acfsim12, width = 700, height = 400) %>%
  layout(title="ACF", xaxis = list(title ="Lags"), yaxis = list(title = "ACF")) %>% 
add_bars(x = ~acfsim12$lag, y = ~acfsim12$acf, width = 0.2, text = paste("ACF =", acfsim12$acf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(acfsim12), y0=CI(sim12a$value), y1=CI(sim12a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(acfsim12), y0=-CI(sim12a$value), y1=-CI(sim12a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

plotpacfsim12 <- plot_ly(pacfsim12, width = 700, height = 400) %>%
  layout(title="PACF", xaxis = list(title ="Lags"), yaxis = list(title = "PACF")) %>% 
add_bars(x = ~pacfsim12$lag, y = ~pacfsim12$pacf, width = 0.2, text = paste("PACF =", pacfsim12$pacf)) %>% 
layout(shapes=list(
  list(type='line', x0=0, x1=nrow(pacfsim12), y0=CI(sim12a$value), y1=CI(sim12a$value), line = list(dash = "dot")),
  list(type='line', x0=0, x1=nrow(pacfsim12), y0=-CI(sim12a$value), y1=-CI(sim12a$value), line = list(dash = "dot")))) %>%
layout(margin = list(l = 60, r = 30, b = 60, t = 60, pad = 4))

tagList(subplot(plotacfsim12, plotpacfsim12, nrows = 1, margin = 0.08) %>% 
  layout(title = "ACF y PACF de un proceso ARMA(2,3)",
         yaxis = list(title = "ACF"),
         yaxis2 = list(title = "PACF"),
         xaxis2 = list(title = "Lags"),
         margin = list(r=30, l=60, t=60, b=60, pad = 4),
         height = 400, showlegend = FALSE))
```
</pre>

## Bibliografía
